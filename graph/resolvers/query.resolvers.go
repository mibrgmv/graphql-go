package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"context"
	"errors"
	"fmt"
	"graphql-go/graph"
	"graphql-go/graph/model"
)

// Quiz is the resolver for the quiz field.
func (r *queryResolver) Quiz(ctx context.Context, id string) (*model.Quiz, error) {
	for _, q := range r.quizzes {
		if q.ID == id {
			return q, nil
		}
	}
	return nil, errors.New("quiz not found")
}

// Quizzes is the resolver for the quizzes field.
func (r *queryResolver) Quizzes(ctx context.Context, pageSize *int32, pageToken *string) (*model.QuizzesConnection, error) {
	var size int32 = 10
	if pageSize != nil {
		size = *pageSize
	}

	startIndex := 0
	if pageToken != nil && *pageToken != "" {
		_, err := fmt.Sscanf(*pageToken, "%d", &startIndex)
		if err != nil {
			return nil, errors.New("invalid page token")
		}
	}

	endIndex := startIndex + int(size)
	if endIndex > len(r.quizzes) {
		endIndex = len(r.quizzes)
	}

	items := r.quizzes[startIndex:endIndex]

	var nextPageToken *string
	if endIndex < len(r.quizzes) {
		token := fmt.Sprintf("%d", endIndex)
		nextPageToken = &token
	}

	return &model.QuizzesConnection{
		Items:         items,
		NextPageToken: nextPageToken,
	}, nil
}

// QuestionsByQuiz is the resolver for the questionsByQuiz field.
func (r *queryResolver) QuestionsByQuiz(ctx context.Context, quizID string) ([]*model.Question, error) {
	var result []*model.Question
	for _, q := range r.questions {
		if q.QuizID == quizID {
			result = append(result, q)
		}
	}
	return result, nil
}

// CurrentUser is the resolver for the currentUser field.
func (r *queryResolver) CurrentUser(ctx context.Context) (*model.User, error) {
	userID, ok := ctx.Value("userID").(string)
	if !ok || userID == "" {
		return nil, errors.New("not authenticated")
	}

	for _, u := range r.users {
		if u.ID == userID {
			return u, nil
		}
	}
	return nil, errors.New("user not found")
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, pageSize *int32, pageToken *string) (*model.UsersConnection, error) {
	var size int32 = 10
	if pageSize != nil {
		size = *pageSize
	}

	startIndex := 0
	if pageToken != nil && *pageToken != "" {
		_, err := fmt.Sscanf(*pageToken, "%d", &startIndex)
		if err != nil {
			return nil, errors.New("invalid page token")
		}
	}

	endIndex := startIndex + int(size)
	if endIndex > len(r.users) {
		endIndex = len(r.users)
	}

	items := r.users[startIndex:endIndex]

	var nextPageToken *string
	if endIndex < len(r.users) {
		token := fmt.Sprintf("%d", endIndex)
		nextPageToken = &token
	}

	return &model.UsersConnection{
		Items:         items,
		NextPageToken: nextPageToken,
	}, nil
}

// Query returns graph.QueryResolver implementation.
func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
